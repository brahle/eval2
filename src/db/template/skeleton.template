// zamislio sam generiranje Tuna_server.cpp fajla
// tako da u Tuna_server.skeleton.cpp trazis liniju
// "// Your implementation goes here"
// i kad je nadjes, onda zamijenis sa ovim kodovima:
// funkcije idu po redu, s tim nemamo problema jer ih
// mi generiramo
// svaki kod unutar <tri dash-a> je jedna funkcija

INSERT AFTER #include "Tuna.h"
#include <tuna.h>
#include <server/TThreadedServer.h>
END

INSERT AFTER shared_ptr<TProtocolFactory>
  /*
END

INSERT AFTER server.serve()
  */
 
  TThreadedServer th_server(processor, serverTransport, transportFactory, protocolFactory);
  th_server.serve();

END

INSERT AFTER class TunaHandler

 private:
  Tuna T_;
END

INSERT AFTER port = 9090
  if (argc == 2) {
    port = atoi(argv[1]);
    printf("using port %d\n", port); 
  } else {
    printf("using default port %d\n", port); 
  }
END

###
    return true;
###
###
    _return = T_.simpleQuery(qname, data);
###
###
    _return = T_.doubleQuery(qname, data);
###
###
    _return = T_.fullQuery(qname, data);
###
###
    _return = T_.reserveFrom(qname, data);
###
###
    T_.reserve(ids);
###
###
    return T_.destroy(id);
###
###
    _return = T_.tablename[id % TUNA_MAX_TABLES];
###
###
    return T_.tableMod(tb);
###

// sljedece 5 funkcije se ponove
// onoliko puta koliko ima tablica

### start foreach models
    vector<eval::model::%className%> sol =
      T_.multiGet<eval::model::%className%>(vector<object_id> (1,id));

    _return = sol.size() ? sol.at(0) : eval::model::%className%();
###
###
    _return = T_.multiGet<eval::model::%className%>(ids);
### 
###
    _return = T_.getFrom<eval::model::%className%>(qname, data);
###
###
    return T_.update("%tableName%", serialize(%varName%)); 
###
###
    return T_.insert("%tableName%", serialize(%varName%)); 
###
